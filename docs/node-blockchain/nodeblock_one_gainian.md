# 区块链核心名词科普

## 哈希
<font color=#1E90FF>哈希我们可以理解为指纹，也就是任意长度的数据通过散列算换变换成为固定长度的数据</font>，关于哈希有几个特点：

+ <font color=#3eaf7c>正向快速</font>：固定的数据每次转换成为的哈希值是固定的
+ <font color=#3eaf7c>逆向困难</font>：由数据装换后的哈希无法计算出原始数据
+ <font color=#3eaf7c>输入敏感</font>：哪怕原始数据只变化了一个字母，哈希值都会发生翻天覆地的变化，基本找不到规律
+ <font color=#3eaf7c>碰撞避免</font>：因为在哈希当中存在明文不一样但是哈希一样的“哈希碰撞”的问题，但是`Sha256`算法复杂度特别高，导致基本不会产生碰撞问题

哈希还有个作用就是做校验，尤其在一些操作系统上应用比较多，比如厂商发布了正版的操作系统，然后对其所有数据做哈希计算，并将哈希值公布在官网，你从任意渠道下载的操作系统都可以做数据校验，用结果和厂商在官网公布的哈希值对比，一样就是正版，不一样就是盗版。同样的道理，校验也会在区块链上进行同样作用的使用。

## 共识算法机制
<font color=#1E90FF>共识说白了就是达成一致</font>，在中心化的时代没有共识的概念，因为只有一方决定。现在达成共识的机制有这么几个措施：

### 1. pow工作量证明
英文是`proof of work`，在比特币世界又经常被称为`POW`。简单来说就是一份证明，用来确认你做过一定量的某种工作。

现实生活当中含有大量的这种工作量证明的案例，比如一本毕业证就可以让你向用人单位证明你大概有什么样的学识；交警通过驾驶证来检验开车的人是否会开车。

在计算机世界里，工作量证明机制在垃圾邮件防范和拒绝服务攻击识别上都有应用，主要用于阻止网络上的恶意攻击。<font color=#1E90FF>比特币系统设计里这是用来设计成挖矿系统</font>。

工作量证明系统可以看成是两个步骤，一个是工作；另一个是对工作的验证。这分别对应两个主体，一个是工作者；另一个是验证者。

<font color=#DD1144>系统约定好工作内容，验证者给出工作量，工作者完成工作量，验证者检验工作量是否达标。工作量证明的设计需要达到：工作者是一定要花费一定的时间才能完成工作，但验证者却可以瞬间完成检验</font>。

比特币的发行是通过挖矿来完成的，全网平均十分钟挖出一个区块，系统就发行12.5BTC（最初是50BTC，每挖出21万个区块奖励就减半，现在经过了两次减半，变成了12.5BTC）奖励给成功挖到区块的矿工。

矿工为了挖到区块必须进行“工作量证明”过程，这个计算的内容包含三个要素：<font color=#9400D3>工作量证明函数</font>、<font color=#9400D3>前一个区块</font>及<font color=#9400D3>难度值</font>。<font color=#1E90FF>工作量证明函数是给出了计算方法，前一个区块是这个函数的参数，难度值决定了这个函数的解题需要的计算工作量</font>。

那比特币系统里的工作量证明的过程就是这样的：
+ <font color=#DD1144>矿工在网络中拿到最新一个区块的头部信息</font>；
+ <font color=#DD1144>将拿到的头部信息作为参数，将nonce值从零开始，去计算其双重SHA256值（SHA256（SHA256（头部信息）））</font>；
+ <font color=#DD1144>如果算出的答案不符合要求，则将nonce值增加一个单位，再算</font>；
+ <font color=#DD1144>直到计算出符合难度目标的答案，就挖到一个区块。也就能拿到比特币系统给它发的12.5BTC的区块奖励</font>。

所以<font color=#9400D3>挖矿的本质就是找到一个使最新区块头部信息的SHA256值满足难度目标值条件的nonce值</font>。就目前来说，每成功挖到一次区块，一个矿工就需要尝试几十亿次的nonce值。

比特币的工作量证明机制明确通过数学的方式给出了“工作内容”、“工作量”，以及评价方式。把“付出劳动”即获得“所有权”，通过数学的方式模拟了出来，这是最公平的一种所有权分发机制。这也是为什么我们说比特币是最公平的货币发行机制。

### 2. POS权益证明
如果说`POW`这种方式更像工地搬砖，那么`POS`权益证明就更像现在资本主义公司化的运转，并不是说谁干的活多谁说的算，而是谁的股份多谁说的算。

而且，工作量证明`POW`工作量很大，让矿工们需要使用大量的能量，这样促进了矿池的产生，让区块链变的更加中心化，而不是去中心化，所以必须找到更好的算法，比工作量证明高效甚至更好，这就是<font color=#9400D3>权益证明（POS）</font>

在2011年，在一个比特币论坛中一位名为QuantumMechanic的用户提出一项技术，他称之为"权益证明(proof-of-stake)"。

基础概念是，让每个人互相竞争挖矿是很浪费的。因此相反的是，<font color=#1E90FF>权益证明通过选举的形式，其中任意节点被随机选择来验证下一个区块</font>。

在这里有一些小的术语区别，<font color=#DD1144>权益证明中没有矿工，但是有验证者(validator)。并不让人们”挖(mine)”新区块 而是"铸造(mint)” 或"制造(forge)”新区块</font>。

<font color=#1E90FF>验证者并不是被完全随机选择的，要成为验证者，节点需要在网络中存入一定数量的货币作为权益，可以将这理解为保证金</font>。

<font color=#3eaf7c>权益的份额大小决定了被选为验证者的几率，从而得以创建下一个区块，这是线性相关的</font>。假设Bob在网络中存入100美元 Alice存入1000美元，那么Alice比Bob有高于10倍的几率选为验证者。

因为这偏袒有钱的一方，似乎不太公平，但事实上这比起工作量证明更公平。对于工作量证明，富人可以很大程度上享受经济实力带来的成果。他们为挖矿设备和电力支付的成本并没有直线上升。相反他们购买的越多，获得的越多。

但是让我们回到权益证明，如果一个节点被选出来验证下一个区块，他将检查当中所有的交易是否有效。如果一切没问题，节点则通过该区块，区块将加到区块链中。作为奖励，该节点可获得当中每个交易费。

那么，我们该如何相信网络中的其他验证者?这里需要用到权益了。如果验证者通过了欺诈性交易，他们将失去一部分权益。<font color=#1E90FF>只要权益高于验证者所获得的交易费，我们就可以信任他们能够很好的完成工作。否则，他们失去的钱比能获得的还多</font>。

因此，工作量证明和权益证明的区别是很明显的。<font color=#DD1144>权益证明的优点就是权益证明不会让每个人都对新区块进行挖矿。因此消耗更少的能量，而且更去中心化，但是缺点也很明显：还是需要挖矿，本质上没有解决商业应用的痛点。而且存在51%的攻击的风险，虽然这个貌似是不可能的</font>。

### 3. DPOS代理权益证明
上面介绍的权益证明算法可以将整个区块链网络理解为一家公司，占比最大的人有更多的机会得到区块；对于小股东来说，能产生区块的可能性很小，只能得到股份带来的分红和收益。

但是在这里介绍的<font color=#DD1144>DPOS委托权益证明能够让每一个人选出可以代表自己利益的人参与到获取区块的争夺中，这样多个小股东就能够通过投票选出自己的代理人，争取自己的利益</font>。

在委托权益证明中，每一个参与者都能够选举任意数量的节点生成下一个区块，得票最多的前M个节点会被选择成为区块的创建者，下一个区块的创建者就会从这样一组当选者中随机选取，除此之外，M的数量也是由整个网络投票决定的，所以可以尽可能地保证网络的去中心化，而且最重要的还是随机选出的，也就是说数量M不确定，M中选取哪一个也不确定，再加上足够多的总量，可以确定几乎是不可操控的。

### 4. 总结
<font color=#9400D3>Pow工作量证明</font>：就是大家熟悉的挖矿，通过与或运算，计算出一个满足规则的随机数，即获得本次记账权，发出本轮需要记录的数据，全网其它节点验证后一起存储；

+ 优点：完全去中心化，节点自由进出；
+ 缺点：目前bitcoin已经吸引全球大部分的算力，其它再用Pow共识机制的区块链应用很难获得相同的算力来保障自身的安全；挖矿造成大量的资源浪费；共识达成的周期较长，不适合商业应用

<font color=#9400D3>Pos权益证明</font>：Pow的一种升级共识机制；根据每个节点所占代币的比例和时间；等比例的降低挖矿难度，从而加快找随机数的速度。

+ 优点：在一定程度上缩短了共识达成的时间
+ 缺点：还是需要挖矿，本质上没有解决商业应用的痛点

<font color=#9400D3>DPos股份授权证明机制</font>：类似于董事会投票，持币者投出一定数量的节点，代理他们进行验证和记账。

+ 优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证
+ 缺点：整个共识机制还是依赖于代币，很多商业应用是不需要代币存在的

4、Pool验证池，基于传统的分布式一致性技术，加上数据验证机制；是目前行业链大范围在使用的共识机制
优点：不需要代币也可以工作，在成熟的分布式一致性算法（Pasox、Raft）基础上，实现秒级共识验证；
缺点：去中心化程度不如bictoin；更适合多方参与的多中心商业模式。

## 非对称加密
非对称加密算法需要两个密钥：公钥（`public key`）和私钥（`private key`）。<font color=#DD1144>私钥可以推导出公钥，反之则不行</font>。公钥与私钥是一对，<font color=#1E90FF>如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥</font>，所以这种算法叫作非对称加密算法。

### 1. 私钥如何产生
<font color=#DD1144>私钥就是一组随机的数字或者字符</font>，例如在比特币中，共占有256位，这里的256位是二进位的位，也就是256个或0或1的数字，或者我们说是32个字节的数字串。我们生成私钥从根本上来讲就是生成一个随机的32字节的数字串。这里有两个关键点：<font color=#9400D3>随机</font> 和 <font color=#9400D3>32字节</font>。

这里我们就应该知道<font color=#DD1144>私钥的产生是不依赖与网络的，是可以自己生成</font>，比如我以投硬币的方式来决定这256位上的数是0还是1，在我们项目生成自己的私钥时，都是离线的方式生成私钥：即用一个随机数来生成一个32字节的数字串。

### 2. 公钥如何产生
有了私钥后，通过一定的算法，比如椭圆曲线算法，比如RSA算法，在比特币等区块链系统中，都是应用椭圆曲线算法来生成公钥，大家可以理解为用一个公式来根据私钥得到公钥。具体公式是什么，依赖于不同的算法。

在这里，<font color=#DD1144>我们可以看到公、私钥的生成都是离线的，是不依赖与任何网络系统的，这一点至关重要</font>。

### 3. 签名与验签
消息传递的主体有两方：`A`与`B`,现在我们假设`A`有自己的一对公钥与私钥，`A`已经向`B`公布了自己的公钥，在`A`向`B`传输消息的时候，`A`的私钥比如是：`woniu`,那么传输的内容要包含：
+ <font color=#9400D3>公钥</font>
+ <font color=#9400D3>验证消息本身</font>
+ <font color=#9400D3>用自己私钥对这个消息的签名</font>

<img :src="$withBase('/blockchain_one_rsa.png')" alt="非对称加密">

当`B`收到`A`发来的内容（包括`A`<font color=#9400D3>公钥</font>，<font color=#9400D3>验证消息</font>，`A`的<font color=#9400D3>签名</font>）时，根据内容中包含的“<font color=#3eaf7c>验证消息本身</font>”与“<font color=#3eaf7c>签名</font>”，用`A`的<font color=#3eaf7c>公钥</font>去验证这个“签名”是否有效。至于如何验证，这是算法的事，验证通过，说明这个确实是`A`正确的公钥。同理如果两个人互相通信，那么`B`也要给`A`打包发送自己的公钥，签名和验证信息，让`A`验证，都验证无误后，大家都拿到了对方正确的公钥。

### 4. 加密与解密
消息传递的主体有两方：`A`与`B`,通过上面的前面和验签的过程，`A`和`B`都拿到了对方正确的公钥，此时发送消息就变的简单了许多：
+ <font color=#DD1144>B向A发送消息，发送的内容只包含一个部分：用A公钥加密后的密文。A在收到消息时，直接用自己的私钥进行解密，得到明文</font>。
+ <font color=#DD1144>A向B发送消息，发送的内容只包含一个部分：用B公钥加密后的密文。B在收到消息时，直接用自己的私钥进行解密，得到明文</font>。

说了许多，非对称加密好像非常好，但是非对称加密也是有自己的不足的，那就是：<font color=#1E90FF>运算速度慢，加密效率低</font>。

## 拜占庭将军问题-容错
### 1. 什么是拜占庭将军问题
拜占庭将军问题是`Leslie Lamport`（2013 年的图灵讲得主）用来为描述<font color=#9400D3>分布式系统一致性问题</font>（Distributed Consensus）在论文中抽象出来一个著名的例子。

在一个分布式系统中肯定有会错误出现，比如有一些节点挂掉了，被黑了导致发送错误的信息，这个时候怎么达成一致？这个问题最早叫做<font color=#1E90FF>拜占庭将军问题</font>：拜占庭帝国想要进攻一个强大的敌人，为此派出了 10 支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御 5 支常规拜占庭军队的同时袭击。这 10 支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少 6 支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于 6 支军队在同一时间一起发起进攻，从而赢取战斗？

当然还有另外的版本，是邻国一起攻占拜占庭帝国，无论怎么样，问题都是<font color=#DD1144>所有将军如何能过达成共识</font>，针对拜占庭问题的深入研究，科学家们得出一个结论：<font color=#DD1144>如果叛徒的数量大于或等于1/3，拜占庭问题不可解</font>。

科学家们提出了口头信息方案和书面协议两个方案（如果有兴趣可以看看这个[网址](https://www.jianshu.com/p/5fea30b25f0a)）。但真正解决这以难题的是——中本聪。

### 2. 中本聪的解决方案
在出现比特币之前，解决分布式系统一致性问题主要是 Lamport 提出的`Paxos`算法或其衍生算法。`Paxos`类算法仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。

<font color=#1E90FF>互联网的存在，首先降低了信息的流通成本</font>。每个将军配一台电脑，就解决了”书面协议“中骑马通讯造成时间延迟的问题。

如果10个将军中的几个同时发起消息，势必会造成系统的混乱，造成各说各的攻击时间方案，行动难以一致。

谁都可以发起进攻的信息，但由谁来发出呢？<font color=#1E90FF>中本聪巧妙地在个系统加入了发送信息的成本，即：一段时间内只有一个节点可以传播信息</font>。

<font color=#DD1144>它加入的成本就是”工作量“——节点必须完成一个计算工作才能向各城邦传播消息，当然，谁第一个完成工作，谁才能传播消息</font>。

<font color=#1E90FF>当某个节点发出统一进攻的消息后，各个节点收到发起者的消息必须签名盖章，确认各自的身份。中本聪在这里引用现代加密技术为这个信息签名</font>。

这种加密技术——非对称加密完全可以解决古代难以解决的签名问题：
+ <font color=#9400D3>消息传送的私密性</font>
+ <font color=#9400D3>能够确认身份</font>
+ <font color=#9400D3>签名不可伪造、篡改</font>

非对称加密算法的加密和解密使用不同的两个密钥.这两个密钥就是我们经常听到的"公开密钥"(公钥)和"私有密钥"(私钥).

公钥和私钥一般成对出现, 如果消息使用公钥加密,那么需要该公钥对应的私钥才能解密; 同样，如果消息使用私钥加密,那么需要该私钥对应的公钥才能解密.

非对称加密的作用是:<font color=#1E90FF>保护消息内容, 并且让消息接收方确定发送方的身份</font>.

比如，将军A想给将军B发送消息，为防止消息泄露，将军A只需要使用B的公钥对信息加密，而B的公钥是公开的，B只需要用只有他自己只的私钥解密即可。

将军B想要在信件上声明自己的身份，他可以自己写一段”签名文本“，并用私钥签名，并广播出去，所有人可以根据B的公钥来验证该签名，确定的B的身份(<font color=#DD1144>这个就是我们在非对称加密算法中的签名和验签的过程</font>)。

由此，一个不可信的分布式网络变成了一个可信的网络，所有的参与者可以在某件事在达成一致。

写到这里，同时终于明白了工作量证明（Proof Of Work）的意义。有人说挖矿浪费了巨大的社会资源，但建立信任的成本可不是0，挖矿是维护比特币网络可靠性的最好办法。

工作量证明，简单的理解就是一份证明，现实中的毕业证、驾驶证都属于工作量证明，它用以检验结果的方式证明你过去所做过了多少工作。

在拜占庭的系统里，加入工作量证明，其实就是简单粗暴地引入了一个条件：<font color=#1E90FF>大家都别忙着发起消息，都来做个题，看谁最聪明，谁就有资格第一个发起消息</font>。

这个题必须是绝对公平的，中本聪在设计比特币时，它采用了一种工作量证明机制叫哈希现金，在一个交易块这要找到一个随机数，计算机只能用穷举法来找到这个随机数，可以说，能不能找到全靠运气，所以对于各个节点来说，这个世界上，只有随机才是真正的公平，实现随机的最好办法是使用数学，所有的将军在寻找共识的过程，借助了大家都认可的数学逻辑。

<font color=#1E90FF>如果不同的将军先后解出了题，各自先后向这个网络发布消息，于是各个节点都会收到来自不同节点发起的进攻或者不进攻的消息，那怎么办的？只有时间最早的发起者才是有效的。中本聪巧妙的设计了一个时间戳的东西，为每个将军在解好题的时间（出块时间）盖上时间印章</font>。

将军们那又凭什么要一起做工作量证明呢？中本聪也完全可以设置一个奖励机制，比特币的奖励机制是每打包一个块，目前是奖励25个比特币，当然，拜占庭将军问题的奖励机制可以是瓜分拜占庭获得的利益。

对了，如果有出现背叛怎么办？

在这个分布式网络里：

<font color=#1E90FF>每个将军都有一份实时与其他将军同步的消息账本。账本里有每个将军的签名都是可以验证身份的。如果有哪些消息不一致，可以知道消息不一致的是哪些将军。尽管有消息不一致的，只要超过半数同意进攻，少数服从多数，共识达成</font>。
由此，在一个分布式的系统中，尽管有坏人，坏人可以做任意事情（不受protocol限制），比如不响应、发送错误信息、对不同节点发送不同决定、不同错误节点联合起来干坏事等等。但是，只要大多数人是好人，就完全有可能去中心化地实现共识（Consensus）。

<font color=#DD1144>区块链上的共识机制主要解决由谁来构造区块，以及如何维护区块链统一的问题</font>。

<font color=#DD1144>拜占庭容错问题需要解决的也同样是谁来发起信息，如何实现信息的统一同步的问题</font>。

到这里也可以知道了，基于互联网的区块链技术，它克服了口头协议与书面协议的种种缺点，使用消息加密技术、以及公平的工作量证明机制，创建了一组所有将军都认可的协议，这套协议的出现，拜占庭将军问题也就完美的得到了解决。

伟大的创新往往是站在前人的肩膀上，中本聪就是各种前沿技术的整合者，古老的疑难杂症在这种整合创新下，就变得不再是问题了。

### 3. 拜占庭容错核心
“拜占庭将军问题”模型中，对于将军们（节点）有两个默认的假设： 
+ <font color=#DD1144>所有忠诚的将军收到相同的命令后，执行这条命令得到的结果一定是相同的</font>；
+ <font color=#DD1144>如果命令是正确的，那么所有忠诚的将军必须执行这条命令</font>。

假设1的含义是：所有节点对命令的解析和执行是一样的，这个命令必须是一个确定性的命令，不能存在随机性，也不能依赖节点自身的状态。（这个命令不能是心情好就攻击敌人，心情不好就原地休息。）

假设2的含义是：忠诚的将军需要判断接收到的命令是不是正确的。<font color=#9400D3>这个判断命令的方法是整个拜占庭容错技术的核心</font>。

对于将军们的通信过程，在“拜占庭将军问题”中也是有默认假设的：点对点通信是没问题的。也就是说，在这里，我们假设`A`将军要给`B`将军一条命令`X`，那么派出去的传令兵一定会准确的把命令`X`传递给`B`将军(这个问题已经被非对称加密算法的整个过程解决)。

有了上述假设，我们来看看将军们面临的核心问题是什么：

我们考虑4个将军的情况，同时假设4个将军中最多只有1个背叛者。
+ 当4个将军A、B、C、D把敌人包围了之后，必须协商一个统一的时间去发起进攻。这时，A将军派出了3个传令兵，分别告诉B、C、D将军，下午1点准时发起进攻。到了下午1点，A、C、D三个将军发起了进攻，歼灭了敌人，同时他们三个发现B是背叛的。虽然B背叛了，但是对最终任务没有影响。

+ 但如果A是背叛的，会发生什么情况？A派出3个传令兵，分别告诉B、C、D将军在下午1点、2点、3点发起进攻。于是，到了下午1点，B将军去攻击敌人，由于寡不敌众，全军覆没；2点，C将军全军覆没；3点，D将军全军覆没。

+ 因为对于忠诚的将军来说，他不知道谁是背叛者，所以，他不能完全相信接收到的命令，他必须对命令做出判断。<font color=#DD1144>在1999年，著名的PBFT算法出现了。这个算法说起来也不难理解，他的核心思想是：对于每一个收到命令的将军，都要去询问其他人，他们收到的命令是什么</font>。

<font color=#1E90FF>**① B是叛徒**</font>


对于上面的第一种情况，假设`B`、`C`、`D`中的`B`是叛徒。在`A`告诉`B`、`C`、`D`下午1点进攻时，`B`、`C`、`D`三人之间会有一次信息交互，它们会分别把自己收到的信息告诉给另外两人。此时不管`B`发出的时间是多少，`C`和`D`两人之中都会得到至少两个是1点的消息，也即[1点（来自A），？点（来自B），1点（来自D）]和[1点（来自A），？点（来自B），1点（来自C）]。这种情况下，1点是占多数的信息。对于C和D而言，此时不能判断谁是叛徒（如果A是叛徒，但是发给C和D 1点；而发给B ？点）。但是不管怎么样，C和D都能放心执行1点进攻的命令。

+ 对于`C`和`D`而言，如果`A`是叛徒，那么`B`会收到来自`C`和`D`的两条1点进攻的消息，所以`B`、`C`和`D`都会在1点发起进攻；忠诚的将军获胜；
+ 对于C和D而言，如果`B`是叛徒，那么`A`、`C`和`D`将会同时在1点发起进攻；忠诚的将军获胜。

<font color=#1E90FF>**② A是叛徒**</font>

对于上面的第二种情况，`A`是背叛者的情况，在`A`告诉`B`、`C`、`D`三个不同的时间之后，`B`、`C`、`D`三人之间会有一次信息交互，它们会分别把自己收到的信息告诉给另外两人。在这种情况下，`B`会收到[1点（来自A），2点（来自C），3点（来自D）]三个不同的时间，`C`同样会收到三个不同的时间[1点（来自B），2点（来自A），3点（来自D）]，以及D会收到[1点（来自B），2点（来自C），3点（来自A）]。

这样，在叛徒数不超过三分之一的情况下，也即`B`、`C`、`D`都知道最多只有一个叛徒的情况下，三人都能判断出`A`是叛徒。

<font color=#1E90FF>**③ 区块链一致性**</font>

以上的讨论主要是对应于一种情况：<font color=#DD1144>所有传递的消息都是口头消息。口头消息和书写消息的不同是，消息的接收方无法判断消息的正确性</font>。例如，在B是叛徒的情况下，即使A告诉B要“下午1点进攻”，B可以篡改消息成“A告诉我要下午2点进攻”。此时C和D无法判断到底是A还是B在撒谎。

另一种考虑的情况是：<font color=#DD1144>消息传递采用书写的形式</font>。在这里，书写意味着A可以使用特殊的笔迹或者在命令上加盖自己的印章，而笔迹或者印章是不可伪造的。那么问题可以简化为A将军用写下的“下午1点进攻”消息，加盖印章，然后传给B，因为有印章，所以B无法篡改A的消息，同时在纸上加盖自己的印章，然后把这张纸传给C，C也加盖印章表示同意，然后D也加盖印章，最后加盖了4个印章的纸再传给没人看一遍，就可以让所有节点一致了。这使得问题大大简化，但采用书面消息的前提是：<font color=#1E90FF>每个将军都知道其他将军的笔迹或印章，并且笔迹或印章无法被模仿，其他将军也容易进行认证；在一次通信中，各个将军是顺序签名的，如果所有的将军同时发消息，那么消息量会大大增加</font>。

对于区块链而言，笔迹或印章的条件是满足的。
+ <font color=#DD1144>相当于每个将军配备一台电脑（相当于分布式的节点），降低了信息流通成本，让信息可以及时地同步到各位将军。而每个人都有一对公私钥，使用私钥进行签名，其他用户使用公钥进行认证。也即，从理论而言，区块链是可以以书写的的方法达到一致性</font>。

+ <font color=#DD1144>同时在限制消息数量的问题上，区块链创新性地引入PoW共识算法，通过工作量证明，增加了发送信息的成本，降低节点发送消息速率，使得一次只有一个用户可以发出消息；同时在广播时会附上自己的签名。类似于将军A向其他的将军（B、C、D…）发起一个提议，将军B、C、D…看到将军A签过名的进攻提议书，诚实的将军在经过验证之后，就会同意进攻提议，而不会发起自己新的进攻提议；如果其中发现错误，才会发起自己的进攻提议</font>。

<font color=#1E90FF>使用区块链语言描述，当一个矿工打包出一个区块之后，其他节点会对这个区块进行验证。如果验证通过，则表明已经有节点发布新区块成功，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争。网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性</font>。

<font color=#1E90FF>假如打包的节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全</font>。

<font color=#1E90FF>工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定</font>。

### 4. 拜占庭容错算法（BFT）
拜占庭将军问题提出后，有<font color=#DD1144>很多的算法被提出用于解决这个问题。这类算法统称拜占庭容错算法</font>（BFT: Byzantine Fault Tolerance）。BFT从上世纪80年代开始被研究，目前已经是一个被研究得比较透彻的理论，具体实现都已经有现成的算法。

<font color=#DD1144>BFT算法中最典型的是PBFT</font>（Practical BFT）。PBFT是由Miguel Castro和Barbara Liskov于1999年提出。PBFT算法解决了之前拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。PBFT在保证安全性和可用性的前提下，提供了 (n-1)/3 的容错性。（细节请参考：PBFT）

PBFT之后，很多进一步提升性能或鲁棒性的BFT算法先后被提出，例如Zyzzyva、ABsTRACTs、Aardvark、RBFT等等。近几年，由于区块链的热度，无数针对区块链应用场景优化过的BFT算法也不断涌现出来。虽然目前PBFT已经不能说是最好的，或最适合区块链的BFT算法。但是PBFT已经足够好了，而且在实际应用中已经非常成熟。

<font color=#DD1144>在BFT共识机制中，网络中节点的数量和身份必须是提前确定好的。BFT共识机制无法做到PoW共识机制中实现的任何人都可以随时加入挖矿。另外，BFT算法无法应用到大量的节点，业内普遍认为100个节点是BFT算法的上限。所以BFT算法无法直接用于公有链，BFT算法适合的场景是私有链和联盟链</font>。业内大名鼎鼎的联盟链Hyperledger fabric v0.6采用的是PBFT，v1.0又推出PBFT的改进版本SBFT。这里再顺便提一句，在可信环境下共识算法一般使用传统的分布式一致算法PAXOS或者RAFT。

公有链使用BFT的一个例外是NEO，NEO使用了DBFT（delegated BFT）共识机制。DBFT共识机制下投票选出7个共识节点。这些代理节点是通过静态选出的，并完全由项目方部署。这也是NEO被外界质疑过于中心化的原因。（参考：早期公有链明星项目-NEO）

<font color=#DD1144>BFT算法和公有链合适的结合点在于基于BFT的PoS共识算法</font>（BFT based PoS）。基于BFT的PoS共识算法要点有： 

+ 一，网络节点通过锁定虚拟资产申请成为区块链系统的验证者（或矿工）。系统验证者的数量是动态变化的。
+ 二，系统从当前验证者中随机选择一个人作为区块提案人。
+ 三，系统验证者对区块提案进行投票表决，投票可能要进行多轮才能达成共识。每个人的投票比重与锁定的虚拟资产成比例。

<font color=#9400D3>基于BFT的PoS的典型例子是tendermint（Cosmos采用了tendermint作为共识核心）。</font>

## p2p网络
`p2p`叫做<font color=#DD1144>点对点</font>的网络系统，是区块链网络的基础，比如你下载了一个比特币的软件，你打开软件你就是比特币系统中的一个节点。但是重要的是你需要一个公网ip,我们常用的迅雷，电驴这种都是`p2p`下载。如果你上传了你的视频到服务器，所有人都来你这里下载，你的服务器的带宽是扛不住的，我只会告诉你其他的下载节点在哪里，这样就分摊了服务器的压力。

对于以太坊这种使用的是：<font color=#1E90FF>完全去中心化的分布式哈希表DHT算法思想的Kadamlia具体实现的网络</font>

区块链本质就是一种不可篡改且可追踪溯源的哈希链条；宏观上，还具备了另外三个基本特征：<font color=#9400D3>分布式存储</font>、<font color=#9400D3>P2P网络</font>和<font color=#9400D3>共识机制</font>。分布式存储无非就是网络上大部分节点都保存了整条区块链，我们最后讲。但区块链的 P2P 网络和共识机制相对则复杂得多，因此我们就先来了解区块链的`P2P`网络

### 1. p2p网络类型
`P2P`网络不同于传统的客户端/服务端(client/server,C/S)结构，<font color=#1E90FF>P2P网络中的每个节点都可以既是客户端也是服务端</font>，因此也不适合使用`HTTP`协议进行节点之间的通信，一般都是直接使用`Socket`进行网络编程。

`P2P`主要存在四种不同的网络模型，也代表着`P2P`技术的四个发展阶段：<font color=#9400D3>集中式</font>、<font color=#9400D3>纯分布式</font>、<font color=#9400D3>混合式</font>和<font color=#9400D3>结构化模型</font>。不过需要指出的是，<font color=#1E90FF>这里所说的网络模型主要是指路由查询结构，即不同节点之间如何建立连接通道</font>，两个节点之间一旦建立连接，具体传输什么数据则是两个节点之间的事情了

+ **<font color=#DD1144>集中式</font>**

  最简单的路由方式就是集中式，<font color=#1E90FF>即存在一个中心节点保存了其他所有节点的索引信息，索引信息一般包括节点 IP 地址、端口、节点资源等</font>。集中式路由的优点就是结构简单、实现容易。但缺点也很明显，由于中心节点需要存储所有节点的路由信息，当节点规模扩展时，就很容易出现性能瓶颈；而且也存在单点故障问题。
  <img :src="$withBase('/blockchain_one_jizhongshi.jpeg')" alt="集中式p2p网络">

+ **<font color=#DD1144>纯分布式</font>**

  那第二种路由结构则是纯分布式的，<font color=#1E90FF>移除了中心节点，在 P2P 节点之间建立随机网络，就是在一个新加入节点和 P2P 网络中的某个节点间随机建立连接通道，从而形成一个随机拓扑结构</font>。新节点加入该网络的实现方法也有很多种，最简单的就是随机选择一个已经存在的节点并建立邻居关系。像比特币的话，则是使用 DNS 的方式来查询其他节点，DNS 一般是硬编码到代码里的，这些 DNS 服务器就会提供比特币节点的 IP 地址列表，从而新节点就可以找到其他节点建立连接通道。新节点与邻居节点建立连接后，还需要进行全网广播，让整个网络知道该节点的存在。全网广播的方式就是，该节点首先向邻居节点广播，邻居节点收到广播消息后，再继续向自己的邻居节点广播，以此类推，从而广播到整个网络。这种广播方法也称为泛洪机制。纯分布式结构不存在集中式结构的单点性能瓶颈问题和单点故障问题，具有较好的可扩展性，但泛洪机制引入了新的问题，主要是可控性差的问题，包括两个较大的问题，一是容易形成泛洪循环，比如节点 A 发出的消息经过节点 B 到 节点 C，节点 C 再广播到节点 A，这就形成了一个循环；另一个棘手问题则是响应消息风暴问题，如果节点 A 想请求的资源被很多节点所拥有，那么在很短时间内，会出现大量节点同时向节点 A 发送响应消息，这就可能会让节点 A 瞬间瘫痪。
  <img :src="$withBase('/blockchain_one_fenbushi.jpeg')" alt="纯分布式P2P网络">

+ **<font color=#DD1144>混合式</font>**

  <font color=#1E90FF>混合式其实就是混合了集中式和分布式结构，网络中存在多个超级节点组成分布式网络，而每个超级节点则有多个普通节点与它组成局部的集中式网络</font>。一个新的普通节点加入，则先选择一个超级节点进行通信，该超级节点再推送其他超级节点列表给新加入节点，加入节点再根据列表中的超级节点状态决定选择哪个具体的超级节点作为父节点。这种结构的泛洪广播就只是发生在超级节点之间，就可以避免大规模泛洪存在的问题。在实际应用中，混合式结构是相对灵活并且比较有效的组网架构，实现难度也相对较小，因此目前较多系统基于混合式结构进行开发实现。<font color=#DD1144>其实，比特币网络如今也是这种结构</font>
  <img :src="$withBase('/blockchanin_one_hunheshi.jpeg')" alt="混合式">

+ **<font color=#DD1144>结构化</font>**
  最后一种网络则是结构化 P2P 网络，<font color=#1E90FF>它也是一种分布式网络结构，但与纯分布式结构不同。纯分布式网络就是一个随机网络，而结构化网络则将所有节点按照某种结构进行有序组织，比如形成一个环状网络或树状网络</font>。而结构化网络的具体实现上，<font color=#1E90FF>普遍都是基于DHT(Distributed Hash Table，分布式哈希表) 算法思想。DHT 只是提出一种网络模型，并不涉及具体实现，主要想解决如何在分布式环境下快速而又准确地路由、定位数据的问题。具体的实现方案有 Chord、Pastry、CAN、Kademlia 等算法，其中 Kademlia也是以太坊网络的实现算法，很多常用的 P2P 应用如 BitTorrent、电驴等也是使用 Kademlia</font>
  
### 2. 比特币网络

### 3. 以太坊网络

## 区块

**参考资料**

1. [共识机制——POW(工作量证明)](https://zhuanlan.zhihu.com/p/37653154)
2. [POS 权益证明究竟是什么](https://zhuanlan.zhihu.com/p/35854600)
3. [白话区块链技术 第1讲｜非对称加密](https://mp.weixin.qq.com/s?__biz=MzUxMTM0MTYzOA==&mid=2247485042&idx=2&sn=a3bb53d29b905106b92facd5f0bd8c59&chksm=f974635bce03ea4d6c742cb73e0b713786264300539381748c3ae3b84ba1e17906f0d01e9e0b&scene=21#wechat_redirect)
4. [什么是拜占庭将军问题](https://learnblockchain.cn/2018/02/05/bitcoin-byzantine)
5. [中本聪与拜占庭将军问题](https://www.jianshu.com/p/5fea30b25f0a)
6. [区块链技术6：拜占庭将军问题](https://zhuanlan.zhihu.com/p/44106775)
7. [区块链研习 | 看懂“拜占庭容错”，也就看懂了区块链的核心技术](https://www.leiphone.com/news/201709/YAd57zwnq8C1IGc2.html)
8. [共识算法4 (BFT)](https://www.jianshu.com/p/5d10cf62d942)
9. [详解区块链P2P网络](https://cloud.tencent.com/developer/article/1183282)
10. [015 | 详解区块链P2P网络](https://cloud.tencent.com/developer/article/1183282)
11. [016 | 漫谈区块链共识机制](https://cloud.tencent.com/developer/article/1183283)
12. [014 | 从微观到宏观理解区块链](https://cloud.tencent.com/developer/article/1183281)